#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Defini√ß√£o da estrutura que representa uma pe√ßa do Tetris. Cada pe√ßa tem:
  // - nome: caractere que indica o tipo ('I', 'O', 'T', 'L')
  // - id: n√∫mero inteiro que identifica de forma √∫nica cada pe√ßa
typedef struct {
    char nome;
    int id;
} Peca;

// Defini√ß√£o da estrutura da Fila Circular. A fila armazenar√° at√© 5 pe√ßas e usar√° √≠ndices para controle:
  // - inicio: posi√ß√£o da pe√ßa que ser√° removida
  // - fim: posi√ß√£o onde ser√° inserida a pr√≥xima pe√ßa
  // - tamanho: quantas pe√ßas est√£o atualmente na fila
typedef struct {
    Peca pecas[5];  // vetor fixo com capacidade para 5 pe√ßas
    int inicio;
    int fim;
    int tamanho;
} Fila;

// Fun√ß√£o: inicializarFila - Objetivo: preparar a fila para uso, zerando os √≠ndices
void inicializarFila(Fila *f) {
    f->inicio = 0;   // primeira posi√ß√£o da fila
    f->fim = 0;      // posi√ß√£o de inser√ß√£o
    f->tamanho = 0;  // inicialmente a fila est√° vazia
}

// Fun√ß√£o: gerarPeca - Objetivo: criar uma nova pe√ßa automaticamente - Retorna: uma struct Peca com tipo aleat√≥rio e id informado
Peca gerarPeca(int id) {
    char tipos[] = {'I', 'O', 'T', 'L'}; // tipos poss√≠veis de pe√ßa
    Peca nova;
    nova.nome = tipos[rand() % 4]; // escolhe aleatoriamente um tipo
    nova.id = id;                  // define o identificador √∫nico
    return nova;                   // retorna a nova pe√ßa gerada
}

// Fun√ß√£o: enfileirar (enqueue) -  Objetivo: inserir uma nova pe√ßa no final da fila
void enfileirar(Fila *f, Peca nova) {
    // Verifica se a fila j√° atingiu sua capacidade m√°xima
    if (f->tamanho == 5) {
        printf("A fila est√° cheia! N√£o √© poss√≠vel adicionar nova pe√ßa.\n");
        return;
    }

    // Insere a nova pe√ßa na posi√ß√£o atual de 'fim'
    f->pecas[f->fim] = nova;

    // Atualiza o √≠ndice 'fim' de forma circular
    // Exemplo: se fim = 4, o pr√≥ximo ser√° 0
    f->fim = (f->fim + 1) % 5;

    // Aumenta o tamanho da fila
    f->tamanho++;
}

// Fun√ß√£o: desenfileirar (dequeue) - Objetivo: remover a pe√ßa mais antiga (da frente da fila)
void desenfileirar(Fila *f) {
    // Verifica se h√° pe√ßas na fila
    if (f->tamanho == 0) {
        printf("A fila est√° vazia! Nenhuma pe√ßa para jogar.\n");
        return;
    }

    // Obt√©m a pe√ßa que est√° na frente da fila
    Peca jogada = f->pecas[f->inicio];

    // Mostra qual pe√ßa foi "jogada" (removida)
    printf("Pe√ßa jogada: [%c %d]\n", jogada.nome, jogada.id);

    // Atualiza o √≠ndice 'inicio' para a pr√≥xima posi√ß√£o
    f->inicio = (f->inicio + 1) % 5;

    // Diminui o tamanho total da fila
    f->tamanho--;
}

// Fun√ß√£o: exibirFila - Objetivo: mostrar todas as pe√ßas atualmente na fila
void exibirFila(Fila *f) {
    printf("\nFila de Pe√ßas:\n");

    // Caso n√£o haja pe√ßas
    if (f->tamanho == 0) {
        printf("(vazia)\n");
        return;
    }

    // Percorre a fila circularmente, exibindo cada pe√ßa
    int i = f->inicio;
    for (int count = 0; count < f->tamanho; count++) {
        printf("[%c %d] ", f->pecas[i].nome, f->pecas[i].id);
        i = (i + 1) % 5; // avan√ßa circularmente
    }
    printf("\n");
}

// Fun√ß√£o principal: main - Objetivo: simular o funcionamento da fila de pe√ßas do Tetris
int main() {
    srand(time(NULL)); // inicializa o gerador de n√∫meros aleat√≥rios

    Fila fila;             // cria a fila principal do jogo
    inicializarFila(&fila); // inicializa a fila vazia

    int idGlobal = 0; // contador global de IDs √∫nicos

    // Preenche a fila com 5 pe√ßas iniciais
    for (int i = 0; i < 5; i++) {
        Peca nova = gerarPeca(idGlobal++);
        enfileirar(&fila, nova);
    }

    int opcao; // vari√°vel para armazenar a escolha do jogador

    // Loop principal do menu
    do {
        exibirFila(&fila); // mostra a fila atual

        // Exibe as op√ß√µes de a√ß√£o
        printf("\nMenu de A√ß√µes:\n");
        printf("1 - Jogar pe√ßa (dequeue)\n");
        printf("2 - Inserir nova pe√ßa (enqueue)\n");
        printf("0 - Sair\n");
        printf("Escolha: ");
        scanf("%d", &opcao);

        // Verifica a op√ß√£o escolhida e executa a a√ß√£o correspondente
        switch (opcao) {
            case 1:
                desenfileirar(&fila); // remove a pe√ßa da frente
                break;
            case 2: {
                // Gera e insere uma nova pe√ßa
                Peca nova = gerarPeca(idGlobal++);
                enfileirar(&fila, nova);
                printf("Nova pe√ßa adicionada: [%c %d]\n", nova.nome, nova.id);
                break;
            }
            case 0:
                printf("üèÅ Encerrando o jogo...\n");
                break;
            default:
                printf("Op√ß√£o inv√°lida!\n");
        }
    } while (opcao != 0); // repete at√© o jogador escolher sair

    return 0; // encerra o programa
}
